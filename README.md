# Crowdsourced Measurements of Internet Traffic Manipulation #

## Stage 1 ##
Stage 1 aims to situate the tester on a global map of internet topology. We draw this map from CAIDA's data sets generated by its Ark monitor network, especially the router-level Macroscopic Internet Topology Data Kit (ITDK). We parse these data sets into a relational database so we can query IP addresses discovered by Paris traceroute for their associated ITDK node ID. Matching nodes from several traces in this manner allows us to place the machine in question on the map.

### CAIDA Macroscopic Internet Topology Data Kit (ITDK) ###

#### Result Suites ####
We'll be using IPv4 Router Topology A and the IPv6 Router Topology. Topology B uses a more comprehensive alias resolution tactic that can also result in false positives. We choose Topology A over B to favor accuracy.

* IPv4 Router Topology A (accurate alias resolution):
  * midar-iff.nodes
  * midar-iff.links
  * midar-iff.nodes.as
  * midar-iff.nodes.geo
  * midar-iff.ifaces


* IPv4 Router Topology B (comprehensive alias resolution):
  * kapar-midar-iff.nodes
  * kapar-midar-iff.links
  * kapar-midar-iff.nodes.as
  * kapar-midar-iff.nodes.geo
  * kapar-midar-iff.ifaces


* IPv6 Router Topology (speedtrap IPv6 alias resolution):
  * speedtrap.nodes
  * speedtrap.links
  * speedtrap.nodes.as
  * speedtrap.nodes.geo

#### File Formats ####
Topology core is given by .nodes and .links. Node metadata is given in .as and .geo. .ifaces attempts to reconstruct node interfaces based on alias resolution.

* itdk-run-<date>.addrs contains the target addresses used by Ark monitors for the ITDK run

* itdk-run-<date>-dns-names.txt contains the DNS entries for every address used or discovered in measurement
  * Format:
```
<timestamp>    <IP-address>    <DNS-name>
```

* .nodes
  * Format:
```
node <node_id>:   <i1>   <i2>   ...   <in>
```
  * Example: node N33382:  4.71.46.6 192.8.96.6 0.4.233.32

* .links
  * Format:
```
link <link_id>:   <N1>:i1   <N2>:i2   [<N3>:[i3] .. [<Nm>:[im]]
```
  * Example:

* .nodes.as
  * Format:
```
node.AS   <node_id>   <AS>   <method>
```
  * Example:

* .nodes.geo
  * Format:
```
node.geo   <node_id>: <continent> <country> <region> <city> <latitude> <longitude>
```
  * Example:

* .ifaces
  * Format:
```
<address> [<node_id>] [<link_id>] [T] [D]
```
  * Example:


### build_map.py ###
This file is reponsible for downloading, decompressing, and parsing CAIDA ITDK data files and then populating a database with the data.
<br><br>
Note that we'll only build this map on a lab computer. It's unnecessary to perform the large and costly process of building the map data structures from the CAIDA data sets on a tester's computer. Also note that we reserve annotation of the topology with metadata like AS number for the analysis stage, so that we can make selective use of the data to mitigate the size of the database.

* Requirements
  * pyodbc Python library
  * cim_util
  * subprocess Python library
  * re Python library

<details>
<summary> download_files(extension, location, day, month, year) </summary>
<p> wgets all of the files we need of a particular ITDK release from CAIDA's file servers. The release is defined by the day, month, and year, which are given as arguments. The file extension is written as a variable to ensure flexibility, but it's usually .bz2. Creates a log from wget's stdout and stderr in case of download issues. </p>
<p> Note that this function requires an internet connection. </p>
</details>

<details>
<summary> decompress(extension, location) </summary>
<p> Decompresses data archives, usually in .bz2 format. Creates a log from bzip2's stdout and stderr in case of problems unzipping the files. </p>
</details>

<details>
<summary> read_in_nodes(ip_version, cursor) </summary>
<p> Opens the .nodes file from the ITDK release specified. Assumes that the file has already been downloaded and decompressed in the specified folder location. Reads the file line by line. When it encounters a line of the format _node N\[node ID number\]: \[IP address\] \[IP address\]...\[IP address\]_, inserts each IP address + node ID pair into the appropriate map_address_to_node table according to IP version. Commits after every matching line. </p>
</details>

<details>
<summary> read_in_links(ip_version, cursor) </summary>
<p> Opens the .links file from the ITDK release specified. Assumes that the file has already been downloaded and decompressed in the specified folder location. Reads the file line by line. When it encounters a line of the format _link L\[link ID number\]: N\[node ID number\]:\[node interface address\]   N\[node ID number\]:\[node interface address\]   \[ N\[node ID number\]:\[node interface address\] .. N\[node ID number\]:\[node interface address\] \]_, inserts each (link ID, node ID 1, node interface address 1, node ID 2, node interface address 2) tuple into the appropriate map_link_to_nodes table according to IP version. Commits after every matching line. </p>
</details>

Right now, build_map.py uses command line arguments, detailed below, but we may rework the file later to draw from cim_util.py and have command line arguments as an option, instead of the primary source of required metadata.

| Option               | Required?          | Description                                          | Default Value |
| -------------------- | ------------------ | ---------------------------------------------------- | ------------- |
| [-h]                 | :x:                | see all argument options                             |               |
| -l FOLDER_LOC        | :heavy_check_mark: | folder path to archive files                         |               |
| [-y YEAR]            | :heavy_check_mark: | year of CAIDA measurements, in 20xx form             | 2019          |
| [-m MONTH]           | :heavy_check_mark: | month of CAIDA measurements, in 01 or 12 form        | 01            |
| [-a DAY]             | :heavy_check_mark: | day of CAIDA measurements, in 03 or 22 form          | 11            |
| [-e COMPRESSION_EXT] | :x:                | compression file extension                           | .bz2          |
| [-x EXTRACT_FILES]   | :x:                | whether to decompress archive files                  | False         |
| [-w DOWNLOAD_FILES]  | :x:                | whether to download data archives from CAIDA servers | False         |

Example command:
```
python build_map.py -l $HOME/Downloads/ITDK-2019-01/ -w True
```

### probe_and_overlay.py ###

* Requirements
  * paris-traceroute tool
    * needs root access
  * pyodbc Python library

<details>
<summary> Hop </summary>
<p>\[Object Class\]</p>
<ul>
<li> hop_count \[Integer\]: number of network hops away from the source. </li>
<li> ip \[String\]: IPv4 or IPv6 address of the network node discovered in this hop. * if blank. </li>
<li> name \[String\]: name of network node. could be same as IP address. * if blank. </li>
<li> times \[List of Floats\]: round-trip times of all successful probe packet and responses for this hop. * if blank. all probes use a set of three packets for each hop. </li>
</ul>
</details>

<details>
<summary> Trace_Path </summary>
<p> \[Object Class\] </p>
<p> This class stores all of the properties of a paris-traceroute output </p>
<ul>
  <li>
    Trace Metadata
    <ul>
      <li> dest_name \[String\]: domain name of trace destination </li>
      <li> dest_addr \[String\]: IPv4 or IPv6 address of trace destination </li>
      <li> hops_max \[Integer\]: maximum TTL of traceroute packets </li>
      <li> pkt_size \[Integer\]: size of trace packets in bytes </li>
      <li> ip_version \[String\]: "IPv4" or "IPv6" to mark which format Hop addresses are in </li>
    </ul>
  </li>
  <li> Hops \[List of Hop Objects\]: all nodes discovered on the route to the targeted domain. </li>
</ul>
</details>

<details>
<summary> run_trace(ipv4) </summary>
<p> Runs a paris-traceroute and directs all stdout and stderr to the file defined by cim_util.s1_trace_log. Adds a -4 or -6 flag to force IPv4 or IPv6 according to the boolean parameter. </p>
<p> Note that this function requires an internet connection. </p>
</details>

<details>
<summary> trim_address(token) </summary>
<p> Removes parentheses and commas from parse tokens that may be IP addresses so that parse_traces() can accurately match tokens. </p>
</details>

<details>
<summary> parse_traces() </summary>
<p> Opens and reads the s1_trace_log to parse Trace_Path objects. Returns a list of Trace_Path objects. Prints all contents of stderr. </p>
</details>

<details>
<summary> match_nodes(trace) </summary>
<p> For every Hop in the Trace_Path given by parameter, selects rows from the map_address_to_node table of the appropriate topology schema to match paris-traceroute measured nodes to ITDK nodes. </p>
</details>

### cim_util.py ###
Contains various utilities: globally useful variables, regular expressions, and functions. All other files are written to pull specific variables from this file.

* Requirements
  * os Python library
  * re Python library
  * time Python library

* Environment Properties
  * user
  * home
  * s1_trace_log

* CAIDA ITDK File Specifications
  * file_types
    * .nodes
    * .links
    * .nodes.as
    * .nodes.geo
    * .ifaces
  * topo_choice
    * midar-iff or kapar-midar-iff for IPv4
    * speedtrap for IPv6

* Regular Expressions
  * node_id_pattern
  * node_entry_prefix
  * link_id_pattern
  * link_entry_prefix
  * ipv4_pattern
  * ipv6_pattern

* ODBC Connection String Fields
  * odbc_driver
  * db_server
  * db_name
  * db_user
  * db_pwd:
    * Obviously we can't store passwords in text variables. Later I'll add some quiet command line prompts for password entry.

<details>
<summary> get_timestamp() </summary>
<p> Returns a timestamp string to mark log files. Format: "\[hour\]-\[minute\]-\[second\]-\[day\]-\[month\]-\[year\]" </p>
</details>

## Stage 2 ##
Forthcoming, will integrate [Ariel's work](https://github.com/TraverAriel/Network-Measurement)

## Stage 3 ##
Forthcoming, will integrate [Ariel's work](https://github.com/TraverAriel/Network-Measurement)
